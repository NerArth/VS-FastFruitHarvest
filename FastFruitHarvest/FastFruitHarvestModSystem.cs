using Vintagestory.API.Client;
using Vintagestory.API.Common;
using Vintagestory.API.Config;
using Vintagestory.API.Server;
using HarmonyLib;
using System.Collections.Generic;
using System.Reflection.Emit;
using Vintagestory.GameContent;
using Vintagestory.Common;
using System.Diagnostics;

namespace FastFruitHarvest
{
    public class FastFruitHarvestModSystem : ModSystem
    {
        private Harmony HI => new Harmony(Mod.Info.ModID);

        public override void StartPre(ICoreAPI api)
        {
            
        }

        // Called on server and client
        // Useful for registering block/entity classes on both sides
        public override void Start(ICoreAPI api)
        {
            //Harmony.DEBUG = true;
            //HI.PatchAll();
            // we could probably just make use of HI.PatchAll(); but I figured I should learn to do it this way since more thought has to go into it
            
            if (api.Side.IsServer()) // only apply the patch server side
            {
                System.Reflection.MethodInfo OriginalFoliageStepMethod = typeof(BlockEntityFruitTreePart).GetMethod("OnBlockInteractStep");
                System.Reflection.MethodInfo OriginalFoliageStopMethod = typeof(BlockEntityFruitTreePart).GetMethod("OnBlockInteractStop");
                api.Logger.Debug("FFH: Applying fruit tree harvesting transpiler");
                //HI.Patch(OriginalFoliageStepMethod, prefix: new HarmonyMethod(typeof(OnBlockInteractStepTranspiler).GetMethod("Prefix")));
                HI.Patch(OriginalFoliageStepMethod, transpiler: new HarmonyMethod(typeof(OnBlockInteractStepTranspiler).GetMethod("Transpiler")));
                HI.Patch(OriginalFoliageStopMethod, transpiler: new HarmonyMethod(typeof(OnBlockInteractStopTranspiler).GetMethod("Transpiler")));
            }
            //api.Logger.Notification("Hello from template mod: " + api.Side);
        }

        public override void StartServerSide(ICoreServerAPI api)
        {
        }

        public override void StartClientSide(ICoreClientAPI api)
        {
        }
        public override void Dispose()
        {
            HI.UnpatchAll(HI.Id);
        }
    }

    // transpilers generated by LLM and slightly modified by myself
    [HarmonyPatch(typeof(BlockEntityFruitTreePart), "OnBlockInteractStep")]
    public class OnBlockInteractStepTranspiler // this makes sure the interaction takes no longer than 0.3 secs
    {
        // Transpiler method that modifies IL
        public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)
        {
            // Convert IEnumerable to a list to make it easier to work with
            var codes = new List<CodeInstruction>(instructions);

            // Iterate over all IL instructions
            for (int i = 0; i < codes.Count; i++)
            {
                Debug.WriteLine("FFH: IL instruction opcode: " + codes[i].opcode);
                Debug.WriteLine("FFH: IL instruction operand: " + codes[i].operand);
                // Look for the specific IL instruction that loads the constant 1.3
                if (codes[i].opcode == OpCodes.Ldc_R8 && (double)codes[i].operand == 1.3)
                {
                    // Modify the return conditional from 1.3 to 0.3
                    codes[i].operand = 0.3;
                }
            }

            // Return the modified instructions
            return codes;
        }
    }

    [HarmonyPatch(typeof(BlockEntityFruitTreePart), "OnBlockInteractStop")]
    public class OnBlockInteractStopTranspiler // this makes sure the interaction can finish once 0.2 secs have passed; effectively there's a 0.1 sec window where you can let go, originally this window is 0.2 sec for some reason, hard to understand why it's even this way
    {
        // Transpiler method that modifies IL
        public static IEnumerable<CodeInstruction> Transpiler(IEnumerable<CodeInstruction> instructions)
        {
            // Convert IEnumerable to a list to make it easier to work with
            var codes = new List<CodeInstruction>(instructions);
            
            // Iterate over all IL instructions
            for (int i = 0; i < codes.Count; i++)
            {
                //Debug.WriteLine("FFH: IL instruction opcode: " + codes[i].opcode);
                //Debug.WriteLine("FFH: IL instruction operand: " + codes[i].operand);
                // Look for the specific IL instruction that loads the constant 1.1
                if (codes[i].opcode == OpCodes.Ldc_R8 && (double)codes[i].operand == 1.1)
                {
                    // Modify the if conditional from 1.1 to 0.2
                    codes[i].operand = 0.2;
                }
            }

            // Return the modified instructions
            return codes;
        }
    }
}
